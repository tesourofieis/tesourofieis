import FontAwesome6 from "@expo/vector-icons/FontAwesome6";
import { useRouter } from "expo-router";
import { useColorScheme } from "nativewind";
import React, { useState, useEffect, useCallback } from "react";
import {
  ScrollView,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { COLORS } from "~/constants/Colors";
import { sidebar } from "../../../../astro/sidebar";

const MainMenuItem = ({ item, onPress, isExpanded }) => {
  const { colorScheme } = useColorScheme();
  const textColor = colorScheme === "light" ? COLORS["800"] : COLORS["200"];
  const iconColor = colorScheme === "light" ? COLORS["600"] : COLORS["400"];

  return (
    <TouchableOpacity
      className="m-2 p-3 flex-row items-center justify-between rounded-lg"
      onPress={onPress}
    >
      <View className="flex-row items-center">
        <Text className="font-bold text-lg" style={{ color: textColor }}>
          {item.label}
        </Text>
      </View>
      {item.items && (
        <FontAwesome6
          name={isExpanded ? "chevron-up" : "chevron-down"}
          size={16}
          color={iconColor}
        />
      )}
      {item.link && (
        <FontAwesome6 name="arrow-right" color={COLORS["500"]} size={16} />
      )}
      {item.autogenerate?.directory && (
        <FontAwesome6 name="arrow-right" color={COLORS["500"]} />
      )}
    </TouchableOpacity>
  );
};

const SubMenuItem = ({ item, onPress, isExpanded }) => {
  const { colorScheme } = useColorScheme();
  const textColor = colorScheme === "light" ? COLORS["700"] : COLORS["300"];
  const iconColor = COLORS["500"];

  return (
    <TouchableOpacity
      className="flex-row items-center justify-between p-3 gap-2"
      onPress={onPress}
    >
      <View className="flex-row items-center">
        <Text className="text-base text-wrap" style={{ color: textColor }}>
          {item.label}
        </Text>
      </View>
      {item.items && (
        <FontAwesome6
          name={isExpanded ? "chevron-up" : "chevron-down"}
          size={13}
          color={iconColor}
        />
      )}
      {item.link && <FontAwesome6 name="arrow-right" color={iconColor} />}
      {item.autogenerate?.directory && (
        <FontAwesome6 name="arrow-right" color={iconColor} size={13} />
      )}
    </TouchableOpacity>
  );
};

const flattenSidebar = (items, parentPath = "") => {
  return items.reduce((acc, item) => {
    const currentPath =
      item.link || (item.autogenerate ? item.autogenerate.directory : null);
    const fullPath = currentPath
      ? `${parentPath}/${currentPath}`.replace(/^\/+/, "/")
      : parentPath;

    if (currentPath) {
      acc.push({
        label: item.label,
        path: fullPath,
      });
    }

    if (item.items) {
      acc = acc.concat(flattenSidebar(item.items, fullPath));
    }

    if (item.autogenerate && !item.items) {
      acc.push({
        label: item.label,
        path: fullPath,
        isAutogenerated: true,
      });
    }

    return acc;
  }, []);
};

export default function MoreScreen() {
  const router = useRouter();
  const [expandedItems, setExpandedItems] = useState({});
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [flattenedSidebar, setFlattenedSidebar] = useState([]);

  useEffect(() => {
    setFlattenedSidebar(flattenSidebar(sidebar));
  }, []);

  const handleSearch = useCallback(
    (text) => {
      setSearchQuery(text);
      if (text) {
        const results = flattenedSidebar.filter((item) =>
          item.label.toLowerCase().includes(text.toLowerCase()),
        );
        // Remove duplicates based on path
        const uniqueResults = results.reduce((acc, current) => {
          const x = acc.find((item) => item.path === current.path);
          if (!x) {
            return acc.concat([current]);
          }

          return acc;
        }, []);
        setSearchResults(uniqueResults);
      } else {
        setSearchResults([]);
      }
    },
    [flattenedSidebar],
  );

  const handleItemPress = (item) => {
    if (item.items) {
      setExpandedItems((prev) => ({
        ...prev,
        [item.label]: !prev[item.label],
      }));
    } else if (item.link || item.path) {
      router.push({
        pathname: "/modal",
        params: { url: (item.link || item.path).slice(1) },
      });
    } else if (item.autogenerate) {
      router.push({
        pathname: "/modal",
        params: { url: item.autogenerate.directory },
      });
    }
  };

  const renderItem = (item, depth = 0) => {
    const isExpanded = expandedItems[item.label];

    return (
      <View
        key={item.label}
        className="bg-sepia-50 dark:bg-sepia-900 border rounded-lg border-sepia-300 p-1 m-1 dark:border-sepia-800"
      >
        {depth === 0 ? (
          <>
            <MainMenuItem
              item={item}
              onPress={() => handleItemPress(item)}
              isExpanded={isExpanded}
            />
          </>
        ) : (
          <SubMenuItem
            item={item}
            onPress={() => handleItemPress(item)}
            isExpanded={isExpanded}
          />
        )}
        {isExpanded && item.items && (
          <View className="ml-4">
            {item.items.map((subItem, _index) =>
              renderItem(subItem, depth + 1),
            )}
          </View>
        )}
      </View>
    );
  };

  const renderSearchResult = (item) => (
    <TouchableOpacity
      key={item.path}
      className="p-3 border-b border-sepia-300 dark:border-sepia-700"
      onPress={() => handleItemPress(item)}
    >
      <Text className="text-sepia-800 dark:text-sepia-200">{item.label}</Text>
    </TouchableOpacity>
  );

  return (
    <ScrollView className="flex-1 p-3">
      <TextInput
        className="bg-sepia-100 dark:bg-sepia-800 text-sepia-800 dark:text-sepia-200 p-3 rounded-lg m-1"
        placeholder="Procurar..."
        placeholderTextColor={COLORS["500"]}
        value={searchQuery}
        onChangeText={handleSearch}
      />
      {searchQuery ? (
        <>{searchResults.map(renderSearchResult)}</>
      ) : (
        sidebar.map((item) => renderItem(item, 0))
      )}
    </ScrollView>
  );
}
